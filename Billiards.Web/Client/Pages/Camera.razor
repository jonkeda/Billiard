@page "/"
@inject IJSRuntime JsRuntime
@inject HttpClient Http
@using Billiards.Web.Client.Components
@using Billiards.Web.Client.Extensions
@using Billiards.Web.Client.Models
@using Billiards.Web.Shared

@* <p>@screenHeight @screenWidth @screenOrientation</p> *@

@if (mode == CameraMode.Camera)
{
    if (mediaDevices != null)
    {
        foreach (var mediaDevice in mediaDevices)
        {
            <button @onclick="@(e => OnSelectMedia(mediaDevice.DeviceId))">
                <span class="oi oi-camera-slr" aria-hidden="true"></span>
            </button>
        }
    }
    <div id="canvas" style="position: relative; width: @screenWidthPx; height: @screenHeightPx">
        <CameraStreamer id="videoContainer"
                    Style=@cameraStyle
                        @ref="CameraStreamerReference"
                        Width="@VideoWidth"
                        Height="@VideoHeight"
                        OnRendered="OnRenderedHandler"
                        OnFrame="OnFrameHandler"
                        CameraID="@cameraId"
                        Autostart/>
        <svg id="svgContainer" viewBox="0 0 @screenWidth @screenHeight"
         style="position: absolute; top: 0px; left: 0px; width: @screenWidthPx; height: @screenHeightPx; z-index: 2">

            @{
                if (balls != null)
                {
                    foreach (var ball in balls)
                    {
                        if (ball.ImageAbsolutePoint != null)
                        {
                            <circle cx="@ball.ImageAbsolutePoint.X" cy="@ball.ImageAbsolutePoint.Y" r="@finderRadius"
                    stroke="@ball.Color" stroke-width="@finderStroke" fill-opacity="0" stroke-opacity="0.5" />
                        }
                    }
                }
            }

            <polygon points="@tableCorners" stroke="green"
                 stroke-width="@finderStroke" stroke-opacity="0.8" fill-opacity="0" />

            Sorry, your browser does not support inline SVG.
        </svg>

        <button style="position: absolute; bottom: 10px; width: @screenWidthPx; height: 30px; z-index: 3; border: none; background: none; "
            @onclick="MakePrediction">
            <span class="oi oi-circle-check" style="background: lightgray; color: green;font-size: 40px; text-align: center" aria-hidden="true"></span>
        </button>

    </div>
}
else if (mode == CameraMode.Prediction)
{
    <div id="canvas" style="position: relative; width: @screenWidthPx; height: @screenHeightPx">
        <svg id="svgContainer" viewBox="0 0 2000 1000" preserveAspectRatio="xMidYMid meet"
         style="position: absolute; top: 1px; width: @screenWidthPx; height: @screenHeightPx; z-index: 2; background-color:green">
            @{
                if (problems != null)
                {
                    foreach (Problem problem in problems)
                    {
                        foreach (Solution solution in problem.Solutions)
                        {
                            <polyline points="@solution.PointsAsString()"
                      style="fill:none;stroke:@problem.Color;stroke-width:3" />
                        }
                    }
                }
                if (balls != null)
                {
                    foreach (var ball in balls)
                    {
                        if (ball.TableAbsolutePoint != null)
                        {
                            <circle cx="@ball.TableAbsolutePoint.X" cy="@ball.TableAbsolutePoint.Y"
                                r="@ballRadius" fill="@ball.Color" />
                        }
                    }
                }
            }

            Sorry, your browser does not support inline SVG.
        </svg>

        <button style="position: absolute; bottom: 10px; width: @screenWidthPx; height: 30px; z-index: 3; border: none; background: none; "
            @onclick="OpenCamera">
            <span class="oi oi-camera-slr" style="background: lightgray; color: green;font-size: 40px; text-align: center" aria-hidden="true"></span>
        </button>
    </div>
}

@code {
    CameraStreamer CameraStreamerReference;

    string cameraId = null;
    MediaDeviceInfoModel[]? mediaDevices;

    CameraMode mode = CameraMode.Camera;

    const int VideoWidth = 960;
    const int VideoHeight = 540;

    const int TableWidth = 2000;
    const int TableHeight = 1000;

    int screenWidth = 480;
    int screenHeight = 270;

    string screenWidthPx = "480px";
    string screenHeightPx = "270px";

    int finderStroke = 8;
    int finderRadius = 16;

    int ballRadius = 16;

    string cameraStyle;

    ScreenOrientation screenOrientation;

    BallCollection? balls;
    ProblemCollection? problems;

    string? tableCorners;

    private async void OnRenderedHandler()
    {
        await SetSize();


        // Check camera-access or ask user, if it's not allowed currently
        if (await CameraStreamerReference.GetCameraAccessAsync())
        {
            // Reloading re-initializes the stream and starts the
            // stream automatically if the Autostart parameter is set
            await CameraStreamerReference.ReloadAsync();

            // If Autostart is not set, you have to manually start the stream again
            /* await CameraStreamerReference.StartAsync(); */
            mediaDevices = await CameraStreamerReference.GetCameraDevicesAsync();
        }
    }

    private async Task SetSize()
    {
        var dimension = await JsRuntime.GetWindowDimension();
        screenWidth = dimension.Width;
        if (screenWidth > 3 * 480)
        {
            screenWidth = Math.Min(screenWidth, 3 * 480);
        }
        else if (screenWidth > 2 * 480)
        {
            screenWidth = Math.Min(screenWidth, 2 * 480);
        }
        else
        {
            screenWidth = screenWidth * 9 / 10;
        }
        screenHeight = screenWidth * 9 / 16;

        finderRadius = Math.Max(screenWidth, screenHeight) / 60;
        finderStroke = Math.Max(screenWidth, screenHeight) / 120;
        ballRadius = Math.Max(screenWidth, screenHeight) / 30;

        screenHeightPx = $"{screenHeight}px";
        screenWidthPx = $"{screenWidth}px";
        screenOrientation = dimension.Orientation;

        cameraStyle = $"position: absolute; top: 0px; left: 0px; width: {screenWidthPx}; height: {screenHeightPx}; z-index: 1";

    }

    private async void OnSelectMedia(string mediaDeviceId)
    {
        await CameraStreamerReference.ChangeCameraAsync(mediaDeviceId);
    }

    private volatile bool sending;
    private async void OnFrameHandler(string data)
    {
        if (sending)
        {
            return;
        }
        try
        {
            data = data[(data.IndexOf(',') + 1)..];

            var addItem = new TableRecognitionRequest(data) ;
            HttpResponseMessage response = await Http.PostAsJsonAsync("Recognition", addItem);
            if (!response.IsSuccessStatusCode)
            {
                return;
            }

            TableRecognitionResponse? result = await response.Content.ReadFromJsonAsync<TableRecognitionResponse>();

            if (mode != CameraMode.Camera
                || result?.Table == null)
            {
                // hide svg
            }
            else
            {
                if (result.Table.Corners.Count < 4)
                {
                    // hide table
                }
                else
                {
                    string corners = "";
                    foreach (Point point in result.Table.Corners)
                    {
                        corners += ToImageAbsolutePoint(point).ToString();
                        corners += " ";
                    }
                    tableCorners = corners;
                }
                if (result.Balls != null)
                {
                    foreach (Ball ball in result.Balls)
                    {
                        if (ball.ImagePoint != null)
                        {
                            ball.ImageAbsolutePoint = ToImageAbsolutePoint(ball.ImagePoint);
                        }
                        if (ball.TablePoint != null)
                        {
                            ball.TableAbsolutePoint = ToTableAbsolutePoint(ball.TablePoint);
                        }
                    }
                    balls = result.Balls;
                }
            }
        }
        finally
        {
            sending = false;
        }
    }

    public Point ToTableAbsolutePoint(Point p)
    {
        return new Point(p.X * TableWidth, p.Y * TableHeight);
    }

    public Point ToImageAbsolutePoint(Point p)
    {
        return new Point(p.X * screenWidth, p.Y * screenHeight);
    }

    public async Task MakePrediction()
    {
        if (balls == null
            || balls.Count < 3)
        {
            return;
        }
        mode = CameraMode.Prediction;
        var request = new PredictionRequest(balls);
        HttpResponseMessage response = await Http.PostAsJsonAsync("Prediction", request);
        if (!response.IsSuccessStatusCode)
        {
            return;
        }
        PredictionResponse? result = await response.Content.ReadFromJsonAsync<PredictionResponse>();
        problems = result?.Problems;
    }

    public void OpenCamera()
    {
        mode = CameraMode.Camera;
    }

}