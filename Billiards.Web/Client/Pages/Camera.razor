@page "/camera"
@inject HttpClient Http
@using Billiards.Web.Client.Components
@using Billiards.Web.Client.Models
@using Billiards.Web.Shared

<div id="canvas" style="position: relative; width: 480px; height: 270px; background-color: antiquewhite;">
    <CameraStreamer id="videoContainer"
                    Style="position: absolute; top: 1px; width: 100%; height: 100%; z-index: 1"
                        @ref="CameraStreamerReference"
                    Width="960"
                    Height="540"
                    OnRendered="OnRenderedHandler"
                    OnFrame="OnFrameHandler"
                    CameraID="@cameraId"
                    Autostart/>
    <svg id="svgContainer" viewBox="0 0 1920 1080" style="position: absolute; top: 1px; width: 100%; height: 100%; z-index: 2">
        
        @{
            if (balls != null)
            {
                foreach (var ball in balls)
                {
                    if (ball.ImageAbsolutePoint != null)
                    {
                        <circle cx="@ball.ImageAbsolutePoint.X" cy="@ball.ImageAbsolutePoint.Y" r="60" stroke="@ball.Color" stroke-width="20" fill-opacity="0" />
                    }
                }
            }
        }
        
        <polygon points="@tableCorners" stroke="green" stroke-width="15" fill-opacity="0" />

        Sorry, your browser does not support inline SVG.
    </svg>
</div>


@{
    if (mediaDevices != null)
    {
        foreach (var mediaDevice in mediaDevices)
        {
            <button @onclick="@(e => OnSelectMedia(mediaDevice.DeviceId))">@mediaDevice.Label</button>
        }
    }
}

@code {
    CameraStreamer CameraStreamerReference;

    string cameraId = null;
    MediaDeviceInfoModel[]? mediaDevices;

    int Width = 1920;
    int Height = 1080;

    BallCollection? balls;

    int redY = 50;
    int redX = 50;

    string? tableCorners;

    private async void OnRenderedHandler()
    {
        // Check camera-access or ask user, if it's not allowed currently
        if (await CameraStreamerReference.GetCameraAccessAsync())
        {
            // Reloading re-initializes the stream and starts the
            // stream automatically if the Autostart parameter is set
            await CameraStreamerReference.ReloadAsync();

            // If Autostart is not set, you have to manually start the stream again
            /* await CameraStreamerReference.StartAsync(); */
            mediaDevices = await CameraStreamerReference.GetCameraDevicesAsync();
        }
    }

    private async void OnSelectMedia(string mediaDeviceId)
    {
        await CameraStreamerReference.ChangeCameraAsync(mediaDeviceId);
    }

    private volatile bool sending;
    private async void OnFrameHandler(string data)
    {
        if (sending)
        {
            return;
        }
        try
        {
            data = data[(data.IndexOf(',') + 1)..];

            var addItem = new ImageData(data) ;
            HttpResponseMessage response = await Http.PostAsJsonAsync("ImageData", addItem);
            TableDetectionResult? result = await response.Content.ReadFromJsonAsync<TableDetectionResult>();

            if (result?.Table == null)
            {
                // hide svg
            }
            else
            {
                if (result.Table.Corners.Count < 4)
                {
                    // hide table
                }
                else
                {
                    string corners = "";
                    foreach (Point point in result.Table.Corners)
                    {
                        corners += ToAbsolutePoint(point).ToString();
                        corners += " ";
                    }
                    tableCorners = corners;
                }
                if (result.Balls != null)
                {
                    foreach (Ball ball in result.Balls)
                    {
                        if (ball.ImagePoint != null)
                        {
                            ball.ImageAbsolutePoint = ToAbsolutePoint(ball.ImagePoint);
                        }
                    }
                    balls = result.Balls;
                }
            }
        }
        finally
        {
            sending = false;
        }
    }

    public Point ToAbsolutePoint(Point p)
    {
        return new Point(p.X * Width, p.Y * Height);
    }

}